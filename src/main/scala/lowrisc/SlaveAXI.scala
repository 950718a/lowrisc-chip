// See LICENSE.Cambridge for license details.

package freechips.rocketchip.lowrisc

import Chisel._
import freechips.rocketchip.config.{Field, Parameters}
import freechips.rocketchip.diplomacy._
import freechips.rocketchip.tilelink._
import freechips.rocketchip.amba.axi4._
import freechips.rocketchip.coreplex.{HasSystemBus, HasMasterAXI4MMIOPortBundle}
import freechips.rocketchip.util.HeterogeneousBag
import scala.collection.mutable.HashMap
import scala.collection.Map

/** The parameters defining an external device on the MMIO AXI
  * @param name         The name of this device
  * @param compat       The list of compatible devices
  * @param range        The register space of this device
  * @param beatBytes    The number of bytes per beat
  * @param burstBytes   The number of bytes per burst
  * @param interrupts   The number of interrupts generated by this device
  * @param readable     Whether the device is readable.
  * @param writeable    Whether the device is writeable.
  * @param executable   Whether the device is executable.
  */
case class ExSlaveParams(
  name: String,
  compat: Seq[String],
  range: AddressSet,
  beatBytes: Int = 4,
  burstBytes: Int = 4,
  interrupts: Int = 0,
  readable: Boolean = true,
  writeable: Boolean = true,
  executable: Boolean = false
)

case object ExPeriperals extends Field[Seq[ExSlaveParams]]

case class AXI4VirtualBusNode(
  masterFn: Seq[AXI4MasterPortParameters] => AXI4MasterPortParameters,
  slaveFn:  Seq[AXI4SlavePortParameters]  => AXI4SlavePortParameters
) extends VirtualBusNode(AXI4Imp)(masterFn, slaveFn)

case class AXI4VirtualSlaveNode(portParams: Seq[AXI4SlavePortParameters])
  extends VirtualSlaveNode(AXI4Imp)(portParams)

trait HasAXI4VirtualBus extends HasSystemBus {

  val mmio_axi4 = AXI4VirtualBusNode(
    masterFn = { m => {
      require(m.size == 1)
      m(0)
    }},
    slaveFn = { s =>
      AXI4SlavePortParameters(
        s.map(_.slaves).flatten,
        s.map(_.beatBytes).min,
        s.map(_.minLatency).min
      )}
  )

  mmio_axi4 :=
    AXI4Buffer()(
    AXI4UserYanker()(
    AXI4Deinterleaver(sbus.blockBytes)(
    AXI4IdIndexer(mmio_axi4.externalEdgesIn(0).bundle.idBits)(
    TLToAXI4(mmio_axi4.externalEdgesIn(0).slave.beatBytes)(
    sbus.toFixedWidthPorts)))))

  // attach virtual slaves
  p(ExPeriperals).foreach( d => {
    val device = new SimpleDevice(d.name, d.compat)
    val slave = AXI4VirtualSlaveNode(
      Seq(AXI4SlavePortParameters(
        slaves = Seq(AXI4SlaveParameters(
          address       = Seq(d.range),
          resources     = device.reg,
          executable    = d.executable,
          supportsWrite = if(d.writeable) TransferSizes(1, d.burstBytes) else TransferSizes.none,
          supportsRead  = if(d.readable) TransferSizes(1, d.burstBytes) else TransferSizes.none
        )),
        beatBytes = d.beatBytes
      )))
    slave :*=  mmio_axi4
  })

}

trait HasAXI4VirtualBusBundle {
  implicit val p: Parameters
  val mmio_axi4: HeterogeneousBag[AXI4Bundle]
}

trait HasAXI4VirtualBusModuleImp extends LazyMultiIOModuleImp with HasAXI4VirtualBusBundle {
  val outer: HasAXI4VirtualBus
  val mmio_axi4 = IO(outer.mmio_axi4.bundleOut)
}

