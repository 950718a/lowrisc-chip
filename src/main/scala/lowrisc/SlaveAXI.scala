// See LICENSE.Cambridge for license details.

package freechips.rocketchip.lowrisc

import Chisel._
import freechips.rocketchip.config.{Field, Parameters}
import freechips.rocketchip.diplomacy._
import freechips.rocketchip.tilelink._
import freechips.rocketchip.amba.axi4._
import freechips.rocketchip.coreplex.{HasSystemBus, HasMasterAXI4MMIOPortBundle}
import freechips.rocketchip.util.HeterogeneousBag
import scala.collection.mutable.HashMap
import scala.collection.Map

/** The parameters defining an external device on the MMIO AXI
  * @param name         The name of this device
  * @param compat       The list of compatible devices
  * @param range        The register space of this device
  * @param burstBytes   The number of bytes per burst
  * @param interrupts   The number of interrupts generated by this device
  * @param readable     Whether the device is readable.
  * @param writeable    Whether the device is writeable.
  * @param executable   Whether the device is executable.
  */
case class ExSlaveParams(
  name: String,
  compat: Seq[String],
  range: AddressSet,
  burstBytes: Int = 64,  // needs to be set >= 64
  interrupts: Int = 0,
  readable: Boolean = true,
  writeable: Boolean = true,
  executable: Boolean = false
)

/** A collection of parameters to define all external devices
  * @param beatBytes    the bus datawidth of the shared mmio port
  * @param idBits       the user id size used to bookkeep control flow
  * @param slaves       the parameters of individual slave devices
  */
case class ExPeriperalsParams(
  beatBytes: Int,
  idBits: Int,
  slaves: Seq[ExSlaveParams]
)

case object ExPeriperals extends Field[ExPeriperalsParams]

case class AXI4VirtualBusNode(
  masterFn: Seq[AXI4MasterPortParameters] => AXI4MasterPortParameters,
  slaveFn:  Seq[AXI4SlavePortParameters]  => AXI4SlavePortParameters
) extends VirtualBusNode(AXI4Imp)(masterFn, slaveFn)

case class AXI4VirtualSlaveNode(portParams: Seq[AXI4SlavePortParameters])
  extends VirtualSlaveNode(AXI4Imp)(portParams)

trait HasAXI4VirtualBus extends HasSystemBus {

  // a virtual bus used as the attach point of slaves
  // also this virtual bus produce the actual mmio output port
  val mmio_axi4 = AXI4VirtualBusNode(
    masterFn = { m => {
      require(m.size == 1)
      m(0)
    }},
    slaveFn = { s =>
      AXI4SlavePortParameters(
        s.map(_.slaves).flatten,
        s.map(_.beatBytes).min,
        s.map(_.minLatency).min
      )}
  )

  // generate and attach virtual slaves
  p(ExPeriperals).slaves.foreach( d => {
    val device = new SimpleDevice(d.name, d.compat)
    val slave = AXI4VirtualSlaveNode(
      Seq(AXI4SlavePortParameters(
        slaves = Seq(AXI4SlaveParameters(
          address       = Seq(d.range),
          resources     = device.reg,
          executable    = d.executable,
          supportsWrite = if(d.writeable) TransferSizes(1, d.burstBytes) else TransferSizes.none,
          supportsRead  = if(d.readable) TransferSizes(1, d.burstBytes) else TransferSizes.none
        )),
        beatBytes = p(ExPeriperals).beatBytes
      )))
    slave :*=  mmio_axi4
  })

  // connect the mmio port to system bus
  mmio_axi4 :=
    AXI4Buffer()(
    AXI4UserYanker()(
    AXI4Deinterleaver(sbus.blockBytes)(
    AXI4IdIndexer(p(ExPeriperals).idBits)(
    TLToAXI4(p(ExPeriperals).beatBytes)(
    sbus.toFixedWidthPorts)))))
}

trait HasAXI4VirtualBusBundle {
  implicit val p: Parameters
  val mmio_axi4: HeterogeneousBag[AXI4Bundle]
}

trait HasAXI4VirtualBusModuleImp extends LazyMultiIOModuleImp with HasAXI4VirtualBusBundle {
  val outer: HasAXI4VirtualBus
  val mmio_axi4 = IO(outer.mmio_axi4.bundleOut)
}

